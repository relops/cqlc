package generator

const Tmpl = `// Code generated by https://github.com/pingginp/cqlc DO NOT EDIT.
// GENERATED USING KEYSPACE {{ .Provenance.Keyspace }}
// AT {{ .Provenance.Timestamp }} USING cqlc VERSION {{ .Provenance.Version }}
// AGAINST HOST ID {{ .Provenance.HostId }} (SERVER VERSION {{ .Provenance.ServerRelease }})
// CLIENT NEGOTIATED CQL VERSION {{ .Provenance.NegotiatedCQL }} (SERVER SUPPORTS UP TO {{ .Provenance.ServerCQL }})

{{ $symbols := .Options.Symbols }}
{{ $keyspace := .Provenance.Keyspace }}

package {{ .Options.Package }}

import (
    {{range $_, $path := .Imports}}
        "{{$path -}}"
    {{- end}}
)

const (
    CQLC_VERSION = "{{ .Provenance.Version }}"
)

{{range $_, $cf := .Tables}}

    {{ $StructType := snakeToCamel $cf.Name }}

    {{range $_, $col := $cf.Columns}}
        {{ $ColStructType := snakeToCamel $col.Name }}
        {{ $QualifiedColStructType := sprint $StructType $ColStructType }}
        type {{$QualifiedColStructType}}Column struct{
            {{ if supportsClustering $col }}
            desc bool
            {{ end }}
        }

        func (b * {{$QualifiedColStructType}}Column ) ColumnName() string {
            return "{{$col.Name}}"
        }

        {{ if isListType $col }}

            func (b * {{$QualifiedColStructType}}Column ) ListType() cqlc.Column {
                return &{{ $QualifiedColStructType }}Column{}
            }

        {{ end }}

        func (b * {{$QualifiedColStructType}}Column ) To(value *{{valueType $col}}) cqlc.ColumnBinding {
            return cqlc.ColumnBinding{Column: b, Value: value}
        }

        {{ if hasSecondaryIndex $col }}
            func (b * {{$QualifiedColStructType}}Column ) Eq(value {{valueType $col}}) cqlc.Condition {
                column := &{{$QualifiedColStructType}}Column{}
                binding := cqlc.ColumnBinding{Column: column, Value: value}
                return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
            }
        {{ end }}

        {{ if isCounterColumn $col }}
            func (b * {{$QualifiedColStructType}}Column ) CanIncrement() bool {
                return true
            }
        {{ else }}
            {{ if supportsPartitioning $col }}
                {{ if not (hasSecondaryIndex $col) }}
                    func (b * {{$QualifiedColStructType}}Column ) Eq(value {{valueType $col}}) cqlc.Condition {
                        column := &{{$QualifiedColStructType}}Column{}
                        binding := cqlc.ColumnBinding{Column: column, Value: value}
                        return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
                    }
                {{ end }}
                func (b * {{$QualifiedColStructType}}Column ) PartitionBy() cqlc.Column {
                    return b
                }
                {{ if isLastComponent $col $cf }}
                    func (b * {{$QualifiedColStructType}}Column ) In(value ...{{valueType $col}}) cqlc.Condition {
                        column := &{{$QualifiedColStructType}}Column{}
                        binding := cqlc.ColumnBinding{Column: column, Value: value}
                        return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
                    }
                {{ end }}
            {{ else if supportsClustering $col }}

                func (b * {{$QualifiedColStructType}}Column ) ClusterWith() string {
                    return b.ColumnName()
                }

                func (b * {{$QualifiedColStructType}}Column ) Desc() cqlc.ClusteredColumn {
                    return &{{$QualifiedColStructType}}Column{desc: true}
                }

                func (b * {{$QualifiedColStructType}}Column ) IsDescending() bool {
                    return b.desc
                }

                {{ if not (hasSecondaryIndex $col) }}
                    func (b * {{$QualifiedColStructType}}Column ) Eq(value {{valueType $col}}) cqlc.Condition {
                        column := &{{$QualifiedColStructType}}Column{}
                        binding := cqlc.ColumnBinding{Column: column, Value: value}
                        return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
                    }
                {{ end }}

                {{ if isLastComponent $col $cf }}
                    func (b * {{$QualifiedColStructType}}Column ) In(value ...{{valueType $col}}) cqlc.Condition {
                        column := &{{$QualifiedColStructType}}Column{}
                        binding := cqlc.ColumnBinding{Column: column, Value: value}
                        return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
                    }
                {{ end }}
                func (b * {{$QualifiedColStructType}}Column ) Gt(value {{valueType $col}}) cqlc.Condition {
                    column := &{{$QualifiedColStructType}}Column{}
                    binding := cqlc.ColumnBinding{Column: column, Value: value}
                    return cqlc.Condition{Binding: binding, Predicate: cqlc.GtPredicate}
                }
                func (b * {{$QualifiedColStructType}}Column ) Ge(value {{valueType $col}}) cqlc.Condition {
                    column := &{{$QualifiedColStructType}}Column{}
                    binding := cqlc.ColumnBinding{Column: column, Value: value}
                    return cqlc.Condition{Binding: binding, Predicate: cqlc.GePredicate}
                }
                func (b * {{$QualifiedColStructType}}Column ) Lt(value {{valueType $col}}) cqlc.Condition {
                    column := &{{$QualifiedColStructType}}Column{}
                    binding := cqlc.ColumnBinding{Column: column, Value: value}
                    return cqlc.Condition{Binding: binding, Predicate: cqlc.LtPredicate}
                }
                func (b * {{$QualifiedColStructType}}Column ) Le(value {{valueType $col}}) cqlc.Condition {
                    column := &{{$QualifiedColStructType}}Column{}
                    binding := cqlc.ColumnBinding{Column: column, Value: value}
                    return cqlc.Condition{Binding: binding, Predicate: cqlc.LePredicate}
                }
            {{ else }}
// Eq is used in DELETE IF statement to filter on non primary key columns, 
// introduced in https://github.com/pingginp/cqlc/issues/13
                func (b * {{$QualifiedColStructType}}Column ) Eq(value {{valueType $col}}) cqlc.Condition {
                    column := &{{$QualifiedColStructType}}Column{}
                    binding := cqlc.ColumnBinding{Column: column, Value: value}
                    return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
                }
            {{ end }}
        {{ end }}

    {{end}}

    type {{$StructType}} struct {
        {{range $_, $col := $cf.Columns}}
            {{snakeToCamel $col.Name}} {{valueType $col -}}
        {{- end}}
    }

    {{range $_, $col := $cf.Columns}}
        func (s * {{$StructType}}) {{snakeToCamel $col.Name}}Value() {{valueType $col}} {
            return s.{{snakeToCamel $col.Name}}
        }
    {{end}}

    type {{$StructType}}Def struct {
        {{range $_, $col := $cf.Columns}}
            {{toUpper $col.Name}} {{columnType $col $cf -}}
        {{- end}}
    }

    func Bind{{$StructType}}(iter *gocql.Iter) ([]{{$StructType}}, error) {
        array := make([]{{$StructType}}, 0)
        err := Map{{$StructType}}(iter, func(t {{$StructType}}) (bool, error) {
            array = append(array, t)
            return true, nil
        })
        return array, err
    }

    func Map{{$StructType}}(iter *gocql.Iter, callback func(t {{$StructType}}) (bool, error)) error {
        columns := iter.Columns()
        row := make([]interface{}, len(columns))

        for {
            t := {{$StructType}}{}

            for i := 0; i < len(columns); i++ {
                switch columns[i].Name {
                {{range $_, $col := $cf.Columns}}
                    case "{{$col.Name}}": row[i] = &t.{{snakeToCamel $col.Name}}
                {{end}}
                default:
                    return errors.Errorf("cqlc: unhandled column: %s", columns[i].Name)
                }
            }
            if !iter.Scan(row...) {
                break
            }

            readNext, err := callback(t)
            if err != nil {
                return err
            }
            if !readNext {
                return nil
            }
        }

        return nil
    }

    {{ if isCounterColumnFamily $cf }}
        func (s * {{$StructType}}Def ) IsCounterTable() bool {
            return true
        }
    {{ else}}
        func (s * {{$StructType}}Def ) SupportsUpsert() bool {
            return true
        }
    {{ end }}

    func (s * {{$StructType}}Def ) TableName() string {
        return "{{$cf.Name}}"
    }

    func (s * {{$StructType}}Def ) Keyspace() string {
        return "{{$keyspace}}"
    }

    func (s * {{$StructType}}Def ) Bind(v {{$StructType}}) cqlc.TableBinding {
        cols := []cqlc.ColumnBinding{
        {{range $_, $col := $cf.Columns}}
            {{ $ColStructType := snakeToCamel $col.Name }}
            {{ $QualifiedColStructType := sprint $StructType $ColStructType }}
            {Column: &{{ $QualifiedColStructType }}Column{}, Value: v.{{snakeToCamel $col.Name}}},
        {{- end}}
        }
        return cqlc.TableBinding{Table: &{{$StructType}}Def{}, Columns: cols}
    }

    func (s * {{$StructType}}Def ) To(v *{{$StructType}}) cqlc.TableBinding {
        cols := []cqlc.ColumnBinding{
        {{range $_, $col := $cf.Columns}}
            {{ $ColStructType := snakeToCamel $col.Name }}
            {{ $QualifiedColStructType := sprint $StructType $ColStructType }}
            {Column: &{{ $QualifiedColStructType }}Column{}, Value: &v.{{snakeToCamel $col.Name}}},
        {{- end}}
        }
        return cqlc.TableBinding{Table: &{{$StructType}}Def{}, Columns: cols}
    }

    func (s * {{$StructType}}Def ) ColumnDefinitions() []cqlc.Column {
        return []cqlc.Column{
            {{range $_, $col := $cf.Columns}}
                {{ $ColStructType := snakeToCamel $col.Name }}
                {{ $QualifiedColStructType := sprint $StructType $ColStructType }}
                &{{ $QualifiedColStructType }}Column{},
            {{- end}}
        }
    }

    func {{$StructType}}TableDef() *{{$StructType}}Def {
        return &{{$StructType}}Def{
            {{range $_, $col := $cf.Columns}}
                {{ $ColStructType := snakeToCamel $col.Name }}
                {{ $QualifiedColStructType := sprint $StructType $ColStructType }}
                {{toUpper $col.Name}} : &{{ $QualifiedColStructType }}Column{},
            {{end}}
        }
    }

    {{ if $symbols }}
        var {{toUpper $cf.Name}} = {{$StructType}}TableDef()
    {{ end }}

    {{range $_, $col := $cf.Columns}}
        {{ $ColStructType := snakeToCamel $col.Name }}
        {{ $QualifiedColStructType := sprint $StructType $ColStructType }}
        func (s *{{$StructType}}Def) {{ $ColStructType }}Column() {{columnType $col $cf }} {
            return &{{ $QualifiedColStructType }}Column{}
        }
    {{end}}

{{end}}
`
