// THIS FILE WAS AUTOGENERATED - ANY EDITS TO THIS WILL BE LOST WHEN IT IS REGENERATED
// GENERATED USING KEYSPACE cqlc
// AT 2018-09-15 01:39:27.314369 -0700 PDT m=+0.059257435 USING cqlc VERSION 0.10.5
// AGAINST HOST ID 7276c9e8-28dc-4032-90a1-53aa078997ff (SERVER VERSION 3.1.1)
// CLIENT NEGOTIATED CQL VERSION 3.0.0 (SERVER SUPPORTS UP TO 3.3.1)




package foo

import (
    
        "github.com/gocql/gocql"
    
        "log"
    
        "time"
    
        "github.com/relops/cqlc/cqlc"
    
)

const (
    CQLC_VERSION = "0.10.5"
)



    

    
        
        
        type T1IdColumn struct{
            
        }

        func (b * T1IdColumn ) ColumnName() string {
            return "id"
        }

        

        func (b * T1IdColumn ) To(value *) cqlc.ColumnBinding {
            return cqlc.ColumnBinding{Column: b, Value: value}
        }

        

        
            
                
                    func (b * T1IdColumn ) Eq(value ) cqlc.Condition {
                        column := &T1IdColumn{}
                        binding := cqlc.ColumnBinding{Column: column, Value: value}
                        return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
                    }
                
                func (b * T1IdColumn ) PartitionBy() cqlc.Column {
                    return b
                }
                
                    func (b * T1IdColumn ) In(value ...) cqlc.Condition {
                        column := &T1IdColumn{}
                        binding := cqlc.ColumnBinding{Column: column, Value: value}
                        return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
                    }
                
            
            
        

    
        
        
        type T1StringListColumn struct{
            
        }

        func (b * T1StringListColumn ) ColumnName() string {
            return "string_list"
        }

        

            func (b * T1StringListColumn ) ListType() cqlc.Column {
                return &T1StringListColumn{}
            }

        

        func (b * T1StringListColumn ) To(value *[]) cqlc.ColumnBinding {
            return cqlc.ColumnBinding{Column: b, Value: value}
        }

        

        
            
            
        

    
        
        
        type T1StringMapColumn struct{
            
        }

        func (b * T1StringMapColumn ) ColumnName() string {
            return "string_map"
        }

        

        func (b * T1StringMapColumn ) To(value *map[]) cqlc.ColumnBinding {
            return cqlc.ColumnBinding{Column: b, Value: value}
        }

        

        
            
            
        

    
        
        
        type T1TsColumn struct{
            
        }

        func (b * T1TsColumn ) ColumnName() string {
            return "ts"
        }

        

        func (b * T1TsColumn ) To(value *time.Time) cqlc.ColumnBinding {
            return cqlc.ColumnBinding{Column: b, Value: value}
        }

        

        
            
            
        

    

    type T1 struct {
        
            Id 
        
            StringList []
        
            StringMap map[]
        
            Ts time.Time
        
    }

    
        func (s * T1) IdValue()  {
            return s.Id
        }
    
        func (s * T1) StringListValue() [] {
            return s.StringList
        }
    
        func (s * T1) StringMapValue() map[] {
            return s.StringMap
        }
    
        func (s * T1) TsValue() time.Time {
            return s.Ts
        }
    

    type T1Def struct {
        
            ID 
        
            STRING_LIST 
        
            STRING_MAP 
        
            TS cqlc.TimestampColumn
        
    }

    func BindT1(iter *gocql.Iter) ([]T1, error) {
        array := make([]T1, 0)
        err := MapT1(iter, func(t T1) (bool, error) {
            array = append(array, t)
            return true, nil
        })
        return array, err
    }

    func MapT1(iter *gocql.Iter, callback func(t T1) (bool, error)) error {
        columns := iter.Columns()
        row := make([]interface{}, len(columns))

        for {
            t := T1{}

            for i := 0; i < len(columns); i++ {
                switch columns[i].Name {
                
                    case "id": row[i] = &t.Id
                
                    case "string_list": row[i] = &t.StringList
                
                    case "string_map": row[i] = &t.StringMap
                
                    case "ts": row[i] = &t.Ts
                
                default:
                    log.Fatal("unhandled column: ", columns[i].Name)
                }
            }
            if !iter.Scan(row...) {
                break
            }

            readNext, err := callback(t)
            if err != nil {
                return err
            }
            if !readNext {
                return nil
            }
        }

        return nil
    }

    
        func (s * T1Def ) SupportsUpsert() bool {
            return true
        }
    

    func (s * T1Def ) TableName() string {
        return "t1"
    }

    func (s * T1Def ) Keyspace() string {
        return "cqlc"
    }

    func (s * T1Def ) Bind(v T1) cqlc.TableBinding {
        cols := []cqlc.ColumnBinding{
        
            
            
            cqlc.ColumnBinding{Column: &T1IdColumn{}, Value: v.Id},
        
            
            
            cqlc.ColumnBinding{Column: &T1StringListColumn{}, Value: v.StringList},
        
            
            
            cqlc.ColumnBinding{Column: &T1StringMapColumn{}, Value: v.StringMap},
        
            
            
            cqlc.ColumnBinding{Column: &T1TsColumn{}, Value: v.Ts},
        
        }
        return cqlc.TableBinding{Table: &T1Def{}, Columns: cols}
    }

    func (s * T1Def ) To(v *T1) cqlc.TableBinding {
        cols := []cqlc.ColumnBinding{
        
            
            
            cqlc.ColumnBinding{Column: &T1IdColumn{}, Value: &v.Id},
        
            
            
            cqlc.ColumnBinding{Column: &T1StringListColumn{}, Value: &v.StringList},
        
            
            
            cqlc.ColumnBinding{Column: &T1StringMapColumn{}, Value: &v.StringMap},
        
            
            
            cqlc.ColumnBinding{Column: &T1TsColumn{}, Value: &v.Ts},
        
        }
        return cqlc.TableBinding{Table: &T1Def{}, Columns: cols}
    }

    func (s * T1Def ) ColumnDefinitions() []cqlc.Column {
        return []cqlc.Column{
            
                
                
                &T1IdColumn{},
            
                
                
                &T1StringListColumn{},
            
                
                
                &T1StringMapColumn{},
            
                
                
                &T1TsColumn{},
            
        }
    }

    func T1TableDef() *T1Def {
        return &T1Def{
            
                
                
                ID : &T1IdColumn{},
            
                
                
                STRING_LIST : &T1StringListColumn{},
            
                
                
                STRING_MAP : &T1StringMapColumn{},
            
                
                
                TS : &T1TsColumn{},
            
        }
    }

    

    
        
        
        func (s *T1Def) IdColumn()  {
            return &T1IdColumn{}
        }
    
        
        
        func (s *T1Def) StringListColumn()  {
            return &T1StringListColumn{}
        }
    
        
        
        func (s *T1Def) StringMapColumn()  {
            return &T1StringMapColumn{}
        }
    
        
        
        func (s *T1Def) TsColumn() cqlc.TimestampColumn {
            return &T1TsColumn{}
        }
    


