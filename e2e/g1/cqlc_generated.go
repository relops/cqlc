// Code generated by https://github.com/pingginp/cqlc DO NOT EDIT.
// GENERATED USING KEYSPACE cqlc
// AT 2018-09-15 17:48:05.653436 -0700 PDT m=+0.071792159 USING cqlc VERSION 0.11.0
// AGAINST HOST ID 099d1b1c-5ebe-4c29-951b-81df44232180 (SERVER VERSION 2.1.20)
// CLIENT NEGOTIATED CQL VERSION 3.0.0 (SERVER SUPPORTS UP TO 3.2.1)

package g1

import (
	"github.com/gocql/gocql"
	"github.com/pkg/errors"
	"github.com/relops/cqlc/cqlc"
)

const (
	CQLC_VERSION = "0.11.0"
)

type TblMapSliceIdColumn struct {
}

func (b *TblMapSliceIdColumn) ColumnName() string {
	return "id"
}

func (b *TblMapSliceIdColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *TblMapSliceIdColumn) Eq(value string) cqlc.Condition {
	column := &TblMapSliceIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *TblMapSliceIdColumn) PartitionBy() cqlc.Column {
	return b
}

func (b *TblMapSliceIdColumn) In(value ...string) cqlc.Condition {
	column := &TblMapSliceIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
}

type TblMapSliceSlColumn struct {
}

func (b *TblMapSliceSlColumn) ColumnName() string {
	return "sl"
}

func (b *TblMapSliceSlColumn) ListType() cqlc.Column {
	return &TblMapSliceSlColumn{}
}

func (b *TblMapSliceSlColumn) To(value *[]string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type TblMapSliceSsmColumn struct {
}

func (b *TblMapSliceSsmColumn) ColumnName() string {
	return "ssm"
}

func (b *TblMapSliceSsmColumn) To(value *map[string]string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type TblMapSlice struct {
	Id  string
	Sl  []string
	Ssm map[string]string
}

func (s *TblMapSlice) IdValue() string {
	return s.Id
}

func (s *TblMapSlice) SlValue() []string {
	return s.Sl
}

func (s *TblMapSlice) SsmValue() map[string]string {
	return s.Ssm
}

type TblMapSliceDef struct {
	ID  cqlc.LastPartitionedStringColumn
	SL  cqlc.StringSliceColumn
	SSM cqlc.StringStringMapColumn
}

func BindTblMapSlice(iter *gocql.Iter) ([]TblMapSlice, error) {
	array := make([]TblMapSlice, 0)
	err := MapTblMapSlice(iter, func(t TblMapSlice) (bool, error) {
		array = append(array, t)
		return true, nil
	})
	return array, err
}

func MapTblMapSlice(iter *gocql.Iter, callback func(t TblMapSlice) (bool, error)) error {
	columns := iter.Columns()
	row := make([]interface{}, len(columns))

	for {
		t := TblMapSlice{}

		for i := 0; i < len(columns); i++ {
			switch columns[i].Name {

			case "id":
				row[i] = &t.Id

			case "sl":
				row[i] = &t.Sl

			case "ssm":
				row[i] = &t.Ssm

			default:
				return errors.Errorf("cqlc: unhandled column: %s", columns[i].Name)
			}
		}
		if !iter.Scan(row...) {
			break
		}

		readNext, err := callback(t)
		if err != nil {
			return err
		}
		if !readNext {
			return nil
		}
	}

	return nil
}

func (s *TblMapSliceDef) SupportsUpsert() bool {
	return true
}

func (s *TblMapSliceDef) TableName() string {
	return "tbl_map_slice"
}

func (s *TblMapSliceDef) Keyspace() string {
	return "cqlc"
}

func (s *TblMapSliceDef) Bind(v TblMapSlice) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		{Column: &TblMapSliceIdColumn{}, Value: v.Id},

		{Column: &TblMapSliceSlColumn{}, Value: v.Sl},

		{Column: &TblMapSliceSsmColumn{}, Value: v.Ssm},
	}
	return cqlc.TableBinding{Table: &TblMapSliceDef{}, Columns: cols}
}

func (s *TblMapSliceDef) To(v *TblMapSlice) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		{Column: &TblMapSliceIdColumn{}, Value: &v.Id},

		{Column: &TblMapSliceSlColumn{}, Value: &v.Sl},

		{Column: &TblMapSliceSsmColumn{}, Value: &v.Ssm},
	}
	return cqlc.TableBinding{Table: &TblMapSliceDef{}, Columns: cols}
}

func (s *TblMapSliceDef) ColumnDefinitions() []cqlc.Column {
	return []cqlc.Column{

		&TblMapSliceIdColumn{},

		&TblMapSliceSlColumn{},

		&TblMapSliceSsmColumn{},
	}
}

func TblMapSliceTableDef() *TblMapSliceDef {
	return &TblMapSliceDef{

		ID: &TblMapSliceIdColumn{},

		SL: &TblMapSliceSlColumn{},

		SSM: &TblMapSliceSsmColumn{},
	}
}

var TBL_MAP_SLICE = TblMapSliceTableDef()

func (s *TblMapSliceDef) IdColumn() cqlc.LastPartitionedStringColumn {
	return &TblMapSliceIdColumn{}
}

func (s *TblMapSliceDef) SlColumn() cqlc.StringSliceColumn {
	return &TblMapSliceSlColumn{}
}

func (s *TblMapSliceDef) SsmColumn() cqlc.StringStringMapColumn {
	return &TblMapSliceSsmColumn{}
}

type TblStringMapIdColumn struct {
}

func (b *TblStringMapIdColumn) ColumnName() string {
	return "id"
}

func (b *TblStringMapIdColumn) To(value *string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

func (b *TblStringMapIdColumn) Eq(value string) cqlc.Condition {
	column := &TblStringMapIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.EqPredicate}
}

func (b *TblStringMapIdColumn) PartitionBy() cqlc.Column {
	return b
}

func (b *TblStringMapIdColumn) In(value ...string) cqlc.Condition {
	column := &TblStringMapIdColumn{}
	binding := cqlc.ColumnBinding{Column: column, Value: value}
	return cqlc.Condition{Binding: binding, Predicate: cqlc.InPredicate}
}

type TblStringMapSsmColumn struct {
}

func (b *TblStringMapSsmColumn) ColumnName() string {
	return "ssm"
}

func (b *TblStringMapSsmColumn) To(value *map[string]string) cqlc.ColumnBinding {
	return cqlc.ColumnBinding{Column: b, Value: value}
}

type TblStringMap struct {
	Id  string
	Ssm map[string]string
}

func (s *TblStringMap) IdValue() string {
	return s.Id
}

func (s *TblStringMap) SsmValue() map[string]string {
	return s.Ssm
}

type TblStringMapDef struct {
	ID  cqlc.LastPartitionedStringColumn
	SSM cqlc.StringStringMapColumn
}

func BindTblStringMap(iter *gocql.Iter) ([]TblStringMap, error) {
	array := make([]TblStringMap, 0)
	err := MapTblStringMap(iter, func(t TblStringMap) (bool, error) {
		array = append(array, t)
		return true, nil
	})
	return array, err
}

func MapTblStringMap(iter *gocql.Iter, callback func(t TblStringMap) (bool, error)) error {
	columns := iter.Columns()
	row := make([]interface{}, len(columns))

	for {
		t := TblStringMap{}

		for i := 0; i < len(columns); i++ {
			switch columns[i].Name {

			case "id":
				row[i] = &t.Id

			case "ssm":
				row[i] = &t.Ssm

			default:
				return errors.Errorf("cqlc: unhandled column: %s", columns[i].Name)
			}
		}
		if !iter.Scan(row...) {
			break
		}

		readNext, err := callback(t)
		if err != nil {
			return err
		}
		if !readNext {
			return nil
		}
	}

	return nil
}

func (s *TblStringMapDef) SupportsUpsert() bool {
	return true
}

func (s *TblStringMapDef) TableName() string {
	return "tbl_string_map"
}

func (s *TblStringMapDef) Keyspace() string {
	return "cqlc"
}

func (s *TblStringMapDef) Bind(v TblStringMap) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		{Column: &TblStringMapIdColumn{}, Value: v.Id},

		{Column: &TblStringMapSsmColumn{}, Value: v.Ssm},
	}
	return cqlc.TableBinding{Table: &TblStringMapDef{}, Columns: cols}
}

func (s *TblStringMapDef) To(v *TblStringMap) cqlc.TableBinding {
	cols := []cqlc.ColumnBinding{

		{Column: &TblStringMapIdColumn{}, Value: &v.Id},

		{Column: &TblStringMapSsmColumn{}, Value: &v.Ssm},
	}
	return cqlc.TableBinding{Table: &TblStringMapDef{}, Columns: cols}
}

func (s *TblStringMapDef) ColumnDefinitions() []cqlc.Column {
	return []cqlc.Column{

		&TblStringMapIdColumn{},

		&TblStringMapSsmColumn{},
	}
}

func TblStringMapTableDef() *TblStringMapDef {
	return &TblStringMapDef{

		ID: &TblStringMapIdColumn{},

		SSM: &TblStringMapSsmColumn{},
	}
}

var TBL_STRING_MAP = TblStringMapTableDef()

func (s *TblStringMapDef) IdColumn() cqlc.LastPartitionedStringColumn {
	return &TblStringMapIdColumn{}
}

func (s *TblStringMapDef) SsmColumn() cqlc.StringStringMapColumn {
	return &TblStringMapSsmColumn{}
}
